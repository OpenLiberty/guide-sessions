// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: guide-multipane
:projectid: sessions
:page-duration: 25 minutes
:page-releasedate: 2019-07-01
:page-description: Learn how to create and cache user session data which are shared among server instances.
:guide-author: Open Liberty
:page-tags: ['Java EE' ]
:page-related-guides: ['rest-intro', 'microprofile-openapi', 'kubernetes-intro']
:page-permalink: /guides/{projectid}
:page-search-keywords: ['sessions', 'session persistence', 'sessionCache', 'Hazelcast', 'JCache']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide
:page-seo-title: Caching HTTP session data to share among server instances
:page-seo-description: Learn how to create and cache user session data which are shared among server instances.
= Caching HTTP session data to share among server instances

Learn how to create and work with user session data which are shared among server instances by using Java Caching (JCache) in Open Liberty.

:kube: Kubernetes
:win: WINDOWS
:mac: MAC
:linux: LINUX

// =================================================================================================
// Introduction
// =================================================================================================
== What you'll learn

You'll learn how to set and get session data which can be shared among server instances. 
To demostrate it, you'll also learn how to containerize and run an application in a local 
Kubenetes cluster.

*Session* +
On the internet, the web server doesn't know who you are, or what you do, 
because it's just processing stateless HTTP requests. A session is a way to store 
information to be used across multiple requests.
Session variables store user information like user name or items in a shopping cart.
By default, session variables will time out after 30 minutes of being unused.
Session variables are maintained on a web server. Cookies, which also store user
information, are maintained on a client's computer. For security reasons, using
session is preferred over using cookies for sensitive data. Session hides data
from users. Cookies store data on client's computer, and can be manipulated by a
savvy user to make fake requests to your site.

*Session caching* +
High traffic websites must support thousands of users in a fast and reliable way.
Load balancing requires running several instances of the same application in parallel
so that traffic can be routed to different servers to maximize speed and reliability.
This poses an out-of-sync problem when each server keeps an isolated copy of their 
session data, unless a user is tied to a particular server. Session caching can solve
this problem by allowing all server instances to share caches among each other. 
This eliminates the need to always route a user to the same server instance, 
and also helps in failover situations by distributing the cache.

image::sessionCache.svg[Session Cache,width=100%]

*Application Containerization* +
Application containerization is to bundle an application with all of its required libraries,
dependencies, and configuration files, so that it can run in Docker and any containerization 
ecosystem.

*Kubernetes* +
Kubernetes is an open source container orchestrator that automates many tasks involved in deploying, managing, and scaling containerized applications. If you would like to learn more about Kubernetes, check out the https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes guide^].


// =================================================================================================
// Prerequisites
// =================================================================================================
[role='command']
include::{common-includes}/kube-prereq.adoc[]

// =================================================================================================
// Getting Started
// =================================================================================================
[role="command"]
include::{common-includes}/gitclone.adoc[]

== Creating application

The application that you'll be working with is a shopping cart web service. 
You'll learn how to persist a user's shopping cart data between servers using the
`sessionCache` feature in Open Liberty. The `sessionCache` feature persists HTTP
sessions using JCache. You can have high performance HTTP session persistence
without the use of a relational database.

Navigate to the `start` directory to begin.

[role="code_command hotspot", subs="quotes"]
----
#Create the `CartApplication` class.#
`src/main/java/io/openliberty/guides/cart/CartApplication.java`
----

CartApplication.java
[source, Java, linenums, indent=0, role="code_column"]
----
include::finish/src/main/java/io/openliberty/guides/cart/CartApplication.java[tags=!copyright]
----

The [hotspot file=0]`CartApplication` class extends the generic JAX-RS application class needed to run the
application.

[role="code_command hotspot", subs="quotes"]
----
#Create the `CartResource` class.#
`src/main/java/io/openliberty/guides/cart/CartResource.java`
----

CartResource.java
[source, Java, linenums, indent=0, role="code_column hide_tags=comment"]
----
include::finish/src/main/java/io/openliberty/guides/cart/CartResource.java[]
----

The [hotspot file=1]`CartResource` class defines the REST endpoints at which a user can make
an HTTP request.

The [hotspot=addToCart file=1]`addToCart` and [hotspot=getCart file=1]`getCart` methods
have a number of annotations most of which
are used by the `myOpenAPI` and `jaxrs` features to provide context to
the user interface and map java objects to web resources.
More information about these annotations can be found in the
https://openliberty.io/guides/microprofile-openapi.html#augmenting-the-existing-jax-rs-annotations-with-openapi-annotations[Documenting RESTful APIs^]
and
https://openliberty.io/guides/rest-intro.html#creating-a-jax-rs-application[Creating a RESTful web service^]
guides.

The [hotspot=item hotspot=price file=1]`@PathParam` annotation injects a custom
[hotspot=item file=1]`item` and [hotspot=price file=1]`price` from the POST
request into the method parameter.

The [hotspot=addToCart file=1]`addToCart` method gets the current session and sets a new attribute
stored as the key-value pair `{item}:{price}`. A response is then built and
returned to confirm that an item has been added to your cart or session.

The [hotspot=getCart file=1]`getCart` method will get the current session. Iterate through all key-value
pairs stored in the current session and create a `JsonObject` response that is returned
to confirm the server instance by [hotspot=podname file=1]`pod-name`, the session by [hotspot=sessionid file=1]`session-id`, 
and the item(s) in your cart by [hotspot=cart file=1]`cart`.

== Configuring session persistence

=== Using Client-Server vs Peer-to-Peer

Session caching is only valuable when it's connected to at least
one other member. There are two different ways session caching can behave in a
server environment:

* Client-Server Model: A Liberty server can act as the JCache client and connect
to a dedicated JCache server.
* Peer-to-Peer Model: A Liberty server can connect with other Liberty servers
that are also running with the session cache and configured to be
part of the same cluster.

You'll use the peer-to-peer model for this guide.

=== Configuring Session Persistence with JCache in Open Liberty

JCache stands for Java Caching and is an interface
to standardize distributed caching on the Java platform.
The `sessionCache` feature makes use of JCache which allows for session
persistence by providing a common cache of session data between servers.
This feature doesn't include a JCache implementation.
For this guide, you'll use Hazelcast as an open source JCache provider.

Hazelcast is a JCache provider. Open Liberty needs to be configured to use
HazelCast once the `sessionCache` feature is enabled.

[role="code_command hotspot", subs="quotes"]
----
#Create the `server.xml` config file.#
`src/main/liberty/config/server.xml`
----

server.xml
[source, xml, linenums, indent=0, role="code_column hide_tags=comment"]
----
include::finish/src/main/liberty/config/server.xml[]
----

The [hotspot=library]`library` tag lets the server know where the Hazelcast implementation of
JCache is located by including a library reference. When the maven build is run
the [hotspot=hazelcastjar]`hazelcast.jar` file is downloaded as a dependency and then copied to the
predefined `{shared.resource.dir}` directory.

=== Configuring HazelCast

CartApplication.java
[source, Java, linenums, indent=0, role="code_column hide_tags=comment"]
----
include::finish/src/main/java/io/openliberty/guides/cart/CartApplication.java[]
----

server.xml
[source, xml, linenums, indent=0, role="code_column hide_tags=comment"]
----
include::finish/src/main/liberty/config/server.xml[]
----

By default, all Open Liberty servers running [hotspot=sessionCache file=1]`sessionCache`,
the [hotspot file=0]`CartApplication` you have created,
and Hazelcast will be connected using a peer-to-peer model.

You can create a named cluster group to limit the Hazelcast instances which
automatically join the cluster. This is accomplished by creating a Hazelcast
configuration file.

[role="code_command hotspot file=2", subs="quotes"]
----
#Create a new `hazelcast-config.xml` config file.#
`src/main/liberty/config/hazelcast-config.xml`
----

hazelcast-config.xml
[source, xml, linenums, indent=0, role="code_column hide_tags=comment"]
----
include::finish/src/main/liberty/config/hazelcast-config.xml[]
----

In the [hotspot file=1]`server.xml` file a reference to the Hazelcast config file is made using
the [hotspot=httpSessionCache file=1]`httpSessionCache` tag. When the maven build is run
the [hotspot file=2]`hazelcast-config.xml`
file is copied to the predefined `{shared.resource.dir}` directory.

There are more configuration settings you can explore in the
https://docs.hazelcast.org/docs/latest/manual/html-single/#understanding-configuration[Hazelcast Documentation^].


== Building and running the application

To build the application, run the Maven `install` phase from the command line in the `start` directory:

[role="command"]
```
mvn install
```

This command builds the application and creates a `.war` file in the target directory. It also
configures and installs Open Liberty into the `target/liberty/wlp` directory.

Next, run the Maven `liberty:start-server` goal to start an Open Liberty server instance:

[role="command"]
```
mvn liberty:start-server
```

Point your browser to the link:http://localhost:9080/openapi/ui/[^] URL. This will
display the available REST endpoints.

First, make a POST request to `/cart/{item}&{price}` by expanding the POST
endpoint on the UI and clicking on the `Try it out` button.
The POST request will add a user specified item and price to a session
that represents data in a user's cart.

Then, make a GET request to `/cart` by expanding the GET
endpoint on the UI and clicking on the `Try it out` button. The GET request
will return a pod-name, a session id, and all the items from your session.

After you're done checking out the application, stop the Open Liberty server.

[role="command"]
```
mvn liberty:stop-server
```
== Containizing the application

The first step of deploying the application to Kubernetes is to containerize it with Docker.

The Dockerfile is provided at the start directory.

If you're unfamiliar with Dockerfiles, check out the
https://openliberty.io/guides/docker.html[Using Docker containers to develop microservices^] guide,
which covers Dockerfiles in depth.

Navigate to the `start` directory and run the following command:
[role='command']
```
docker build -t cart-app:1.0-SNAPSHOT .
```

When the build finishes, run the following command to list all local Docker images:
[role='command']
```
docker images
```

Verify that the `cart-app:1.0-SNAPSHOT` image is listed among them, for example:
----
REPOSITORY           TAG          
cart-app             1.0-SNAPSHOT
open-liberty         latest
----

== Deploying the containized application

Now that the containized application is built, deploy it to a local Kubenetes cluster by using 
a Kubernetes resource definition, which is provided in the `kubernetes.yaml` file 
at the start directory.

To demostrate how session data can be shared among server instances, the Kubernetes cluster will start
three instances by [hotspot=replicas file=0]`replicas` definition, and the client request will not route 
to the same instance by anti-affinity configration at the [hotspot=affinity file=0]`affinity` section.

kubernetes.yaml
[source, yaml, linenums, role="code_column hide_tags=comment"]
----
include::finish/kubernetes.yaml[]
----

Run the following commands to deploy the resources as defined in kubernetes.yaml:
[role='command']
```
kubectl apply -f kubernetes.yaml
```

When the application is deployed, run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

You'll see an output similar to the following if all the pods are healthy and running:

[source, role="no_copy"]
----
NAME                             READY  STATUS   RESTARTS  AGE
cart-deployment-98f4ff789-2xlhs  1/1    Running  0         17s
cart-deployment-98f4ff789-6rvfj  1/1    Running  0         17s
cart-deployment-98f4ff789-qrh45  1/1    Running  0         17s
----

Point your browser to the link:http://localhost:31000/openapi/ui/[^] URL. This will
display the available REST endpoints.

Make a POST request to `/cart/{item}&{price}` by expanding the POST
endpoint on the UI and clicking on the `Try it out` button.
The POST request will add a user specified item and price to a session
that represents data in a user's cart.

Then, make a GET request to `/cart` by expanding the GET
endpoint on the UI and clicking on the `Try it out` button. The GET request
will return a pod-name, a session id, and all the items from your session.
Repeat the GET request several times. You'll find out the 



You can also see the items from your session on the REST endpoints that are running on the `server2` server.
Point your browser to the link:http://localhost:9081/openapi/ui/[^] URL.
Make a GET request to `/cart` by expanding the GET
endpoint on the UI and clicking on the `Try it out` button.

As a last step, verify the Hazelcast Cluster is running by checking the Open Liberty log located at
`target/liberty/wlp/usr/servers/server1/logs/messages.log`. If you don't see a message similar to
the one below in this log, you might need to check if multicast is enabled or any firewall is blocking
the multicast packages.

[source, role="no_copy"]
----
Members {size:2, ver:2} [
	Member [172.31.98.59]:5701 - fb4da600-ab54-44cc-bc4e-0fd65b4ee6da this
	Member [172.31.98.59]:5702 - 29b4c11d-fa54-482e-a81d-807eef837249
]
----

After you're done checking out the application, stop the Open Liberty servers.

[role="command"]
```
mvn liberty:stop-server -DserverName=server1
mvn liberty:stop-server -DserverName=server2
```


== Testing your servers

[role="code_command hotspot", subs="quotes"]
----
#Create a `CartSessionTest` class.#
`src/test/java/it/io/openliberty/guides/cart/CartSessionTest.java`
----

CartSessionTest.java
[source, Java, linenums, indent=0, role="code_column"]
----
include::finish/src/test/java/it/io/openliberty/guides/cart/CartSessionTest.java[tags=**;!copyright;!comment]
----

The [hotspot=37-48]`testEmptyCart` test makes sure that the `getCart` endpoint returns
empty when you first start the application. Otherwise, additional tests may cause
errors if you're unable to access this endpoint or if data is already stored in
this session.

The [hotspot=51-72]`testOneServer` test first makes a POST request to the `addToCart` endpoint
and ensures that the expected response is returned. Then, it makes a GET request
to the `getCart` endpoint and ensures that the expected response is returned.
This test uses the same server.

The [hotspot=75-96]`testTwoServers` test makes the same checks as the previous test, but the
`addToCart` endpoint is on the server at port 9080, and the `getCart` endpoint
is on the server at port 9081.

Although REST endpoints are generally stateless, they're used for simplicity in
this guide. The [hotspot=51-72]`testOneServer` and [hotspot=75-96]`testTwoServers` tests use a cookie
to ensure that the same person's session data is being used for the `addToCart`
and `getCart` requests.

Verify that the tests pass using the Maven `verify` goal:

[role="command"]
```
mvn verify
```

If the tests pass, you'll see a similar output to the following:

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.cart.CartSessionTest
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.259 sec

Results :

Tests run: 3, Failures: 0, Errors: 0, Skipped: 0
----

// =================================================================================================
// Tear Down
// =================================================================================================

== Tearing down the environment

When you no longer need your deployed application, you can delete all {kube} resources 
by running the `kubectl delete` command:

[role='command']
```
kubectl delete -f kubernetes.yaml
```

[role='command']
include::{common-includes}/kube-minikube-teardown.adoc[]


== Great work! You're done!

You developed and tested a Java microservice using HTTP session caching and
Open Liberty.

include::{common-includes}/attribution.adoc[subs="attributes"]
