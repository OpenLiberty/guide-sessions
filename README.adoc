// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: guide-multipane
:projectid: sessions
:page-duration: 25 minutes
:page-releasedate: 2019-07-18
:page-description: Learn how to create, use and cache HTTP session data
:guide-author: Open Liberty
:page-tags: ['Docker', 'MicroProfile']
:page-related-guides: ['rest-intro', 'microprofile-openapi', 'kubernetes-intro']
:page-permalink: /guides/{projectid}
:page-search-keywords: ['sessions', 'session persistence', 'sessionCache', 'Hazelcast', 'JCache']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:imagesdir: /img/guide
:page-seo-title: Caching HTTP session data
:page-seo-description: A tutorial on how to create, use and cache HTTP session data for an enterprise Java application 
= Caching HTTP session data

Learn how to create, use and cache HTTP session data for your application

:kube: Kubernetes
:win: WINDOWS
:mac: MAC
:linux: LINUX

// =================================================================================================
// Introduction
// =================================================================================================
== What you'll learn

=== What is a session?
// *Session* +
On the internet, a web server doesn't know who you are, or what you do, 
because it's just processing stateless HTTP requests. A session is a way to store 
information to be used across multiple requests.
Session variables store user information like username, or items in a shopping cart.
 By default, session variables will timeout after 30 minutes of being unused.
Cookies, which also store user
information, are maintained on a client's computer, whereas session variables are maintained on a web server. For security reasons, using
session is preferred over using cookies for sensitive data. Session hides data
from users. Cookies can be manipulated by a
savvy user to make fake requests to your site.

=== What is session persistence? 
// *Session caching* +
High traffic websites must support thousands of users in a fast and reliable way.
Load balancing requires running several instances of the same application in parallel
so that traffic can be routed to different instances to maximize speed and reliability.
This poses an out-of-sync problem when each instance keeps an isolated copy of their 
session data, unless a user is tied to a particular instance. Session caching can solve
this problem by allowing all instances to share caches among each other. 
This eliminates the need to always route a user to the same instance, 
and also helps in failover situations by distributing the cache.

image::sessionCache.png[Session Cache,width=100%]

You will learn how to build an application that creates and uses HTTP session data.
You will also learn how to use Open Liberty's `sessionCache` feature to persist HTTP sessions
using Java Caching (JCache), the standard caching API for Java.

You will containerize and deploy the application to a local Kubernetes cluster.
You will replicate the application in multiple pods and see that the session data is cached and
shared among all instances of the application. Even if an instance is unavailable, the other instances
can take over and handle requests from the same user using the cached session data.


// =================================================================================================
// Prerequisites
// =================================================================================================
[role='command']
include::{common-includes}/kube-prereq.adoc[]

// =================================================================================================
// Getting Started
// =================================================================================================
[role="command"]
include::{common-includes}/gitclone.adoc[]


== Creating the application

The application that youâ€™ll be working with is a shopping cart web service that uses JAX-RS, which is a Java API for building RESTful web services.
You'll learn how to persist a user's shopping cart data between servers using the
`sessionCache` feature in Open Liberty. The `sessionCache` feature persists HTTP
sessions using JCache. You can have high-performance HTTP session persistence
without using a relational database.

Navigate to the `start` directory to begin.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `CartApplication` class.#
`src/main/java/io/openliberty/guides/cart/CartApplication.java`
----
CartApplication.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/src/main/java/io/openliberty/guides/cart/CartApplication.java[]
----

The [hotspot file=0]`CartApplication` class extends the generic JAX-RS application class that is needed to run the
application.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `CartResource` class.#
`src/main/java/io/openliberty/guides/cart/CartResource.java`
----
CartResource.java
[source, Java, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/src/main/java/io/openliberty/guides/cart/CartResource.java[]
----

The [hotspot file=1]`CartResource` class defines the REST endpoints at which a user can make
an HTTP request.

The [hotspot=addToCart file=1]`addToCart` and [hotspot=getCart file=1]`getCart` methods
have a number of annotations; most of which
are used by the MicroProfile Open API and JAX-RS features to document the REST endpoints and map Java objects to web resources.
More information about these annotations can be found in the
https://openliberty.io/guides/microprofile-openapi.html#augmenting-the-existing-jax-rs-annotations-with-openapi-annotations[Documenting RESTful APIs^]
and
https://openliberty.io/guides/rest-intro.html#creating-a-jax-rs-application[Creating a RESTful web service^]
guides.

The [hotspot=endpointCartItemPrice file=1]`cart/{item}&{price}` endpoint demonstrates how to set session data.
The [hotspot=item hotspot=price file=1]`@PathParam` annotation injects a custom [hotspot=item file=1]`item` and 
[hotspot=price file=1]`price` from the POST request into the method parameter.
The [hotspot=addToCart file=1]`addToCart` method gets the current [hotspot=getSession file=1]`session` and binds
the key-value pair `{item}:{price}` into the session by [hotspot=setAttribute file=1]`setAttribute()`. 
A response is then built and returned to confirm that an item has been added to your cart and session.

The [hotspot=endpointCart file=1]`cart` endpoint demonstrates how to get session data.
The [hotspot=getCart file=1]`getCart` method will get the current session, iterate through all key-value
pairs that are stored in the current session, and create a `JsonObject` response that is returned
to confirm the server instance by [hotspot=podname file=1]`pod-name`, the session by [hotspot=sessionid file=1]`session-id`, 
and the items in your cart by [hotspot=cart file=1]`cart`.


== Configuring session persistence

=== Using Client-Server vs Peer-to-Peer Model

Session caching is only valuable when a server connected to at least
one other member. There are two different ways session caching can behave in a
cluster environment:

* Client-Server Model: A Liberty server can act as the JCache client and connect
to a dedicated JCache server.
* Peer-to-Peer Model: A Liberty server can connect with other Liberty servers
that are also running with the session cache and configured to be
part of the same cluster.

You'll use the peer-to-peer model in a Kubernetes environment for this guide. 

=== Configuring Session Persistence with JCache in Open Liberty

JCache stands for Java Caching and is an interface
to standardize distributed caching on the Java platform.
The `sessionCache` feature makes use of JCache that allows for session
persistence by providing a common cache of session data between servers.
This feature doesn't include a JCache implementation.
For this guide, you'll use Hazelcast as an open source JCache provider.

Hazelcast is a JCache provider. Open Liberty needs to be configured to use
Hazelcast once the `sessionCache` feature is enabled.

[role="code_command hotspot", subs="quotes"]
----
#Create the `server.xml` file.#
`src/main/liberty/config/server.xml`
----

server.xml
[source, xml, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/src/main/liberty/config/server.xml[]
----

The [hotspot=library]`<library />` tag lets the server know where the Hazelcast implementation of
JCache is located by including a library reference.
The [hotspot=hazelcastjar]`hazelcast.jar` file is downloaded as a dependency and then copied to the
predefined `{shared.resource.dir}` directory when the Maven build runs. This goal is defined in the
provided Maven POM file.

=== Configuring Hazelcast

server.xml
[source, xml, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/src/main/liberty/config/server.xml[]
----

By default, all Open Liberty servers running [hotspot=sessionCache file=0]`sessionCache` 
and Hazelcast will be connected using a peer-to-peer model.

You can share the session cache only among certain Hazelcast instances 
through using the [hotspot=group file=1]`<group />` configuration tag in Hazelcast configuration file.

[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `hazelcast-config.xml` configuration file.#
`src/main/liberty/config/hazelcast-config.xml`
----

hazelcast-config.xml
[source, xml, linenums, indent=0, role="code_column hide_tags=copyright"]
----
include::finish/src/main/liberty/config/hazelcast-config.xml[]
----

The cluster group [hotspot=cartCluster file=1]`CartCluster` is defined in the [hotspot file=1]`hazelcast-config.xml`.

In the [hotspot file=0]`server.xml` file, a reference to the Hazelcast configuration file is made by using
the [hotspot=httpSessionCache file=0]`httpSessionCache` tag.
The [hotspot file=1]`hazelcast-config.xml` file is copied to the predefined `{shared.resource.dir}` directory
when a Maven build runs. This goal is defined in the provided Maven POM file.

There are more configuration settings that you can explore in the
https://docs.hazelcast.org/docs/latest/manual/html-single/#understanding-configuration[Hazelcast Documentation^].


== Building and running the application

To build the application, run the Maven `install` phase from the command line in the `start` directory:

[role="command"]
```
mvn install
```

This command builds the application and creates a `.war` file in the target directory. It also
configures and installs Open Liberty into the `target/liberty/wlp` directory.

Next, run the Maven `liberty:start-server` goal to start an Open Liberty server instance:

[role="command"]
```
mvn liberty:start-server
```

Point your browser to the link:http://localhost:9080/openapi/ui/[^] URL. This 
displays the available REST endpoints.

First, make a POST request to `/cart/{item}&{price}` by expanding the POST
endpoint on the UI, providing an item and a price, and then clicking the `Try it out` button.
The POST request adds a user specified item and price to a session
that represents data in a user's cart.

Then, make a GET request to `/cart` by expanding the GET
endpoint on the UI and clicking the `Try it out` button. The GET request
returns a pod name, a session id, and all the items from your session.

After you're done checking out the application, stop the Open Liberty server.

[role="command"]
```
mvn liberty:stop-server
```


== Containerizing the application

The first step of deploying the application to Kubernetes is to containerize it with Docker.

The Dockerfile is provided at the `start` directory. If you're unfamiliar with Dockerfile, 
check out the https://openliberty.io/guides/microservices-docker.html[Containerizing microservices^] guide,
which covers Dockerfile in depth.

Navigate to the `start` directory and run the following command:
[role='command']
```
docker build -t cart-app:1.0-SNAPSHOT .
```

When the build finishes, run the following command to list all local Docker images:
[role='command']
```
docker images
```

Verify that the `cart-app:1.0-SNAPSHOT` image is listed among them, for example:
[source, role="no_copy"]
----
REPOSITORY           TAG          
cart-app             1.0-SNAPSHOT
open-liberty         latest
----


== Deploying and running the application in Kubernetes

kubernetes.yaml
[source, yaml, linenums, role='code_column']
----
include::finish/kubernetes.yaml[]
----

Now that the containerized application is built, deploy it to a local Kubernetes cluster by using 
a Kubernetes resource definition, which is provided in the [hotspot file=0]`kubernetes.yaml` file 
at the `start` directory.

Run the following command to deploy the application into [hotspot=replicas file=0]`3` replicated pods as defined 
in kubernetes.yaml:
[role='command']
```
kubectl apply -f kubernetes.yaml
```

When the application is deployed, run the following command to check the status of your pods:
[role='command']
```
kubectl get pods
```

You'll see an output similar to the following if all the pods are working correctly:

[role="no_copy"]
----
NAME                             READY  STATUS   RESTARTS  AGE
cart-deployment-98f4ff789-2xlhs  1/1    Running  0         17s
cart-deployment-98f4ff789-6rvfj  1/1    Running  0         17s
cart-deployment-98f4ff789-qrh45  1/1    Running  0         17s
----

Point your browser to the link:http://localhost:31000/openapi/ui/[^] URL. This
displays the available REST endpoints.

Make a POST request to `/cart/{item}&{price}` by expanding the POST
endpoint on the UI, providing an item and a price, and then clicking the `Try it out` button.
The POST request adds a user specified item and price to a session
that represents data in a user's cart.

Then, make a GET request to `/cart` by expanding the GET
endpoint on the UI and clicking the `Try it out` button. The GET request
returns a pod name, a session id, and all the items from your session.

[role="no_copy"]
----
{
  "pod-name": "cart-deployment-98f4ff789-2xlhs",
  "session-id": "RyJKzmka6Yc-ZCMzEA8-uPq",
  "cart": [
    "eggs | $2.89"
  ],
  "subtotal": 2.89
}
----

Pause the pod for the GET request that you just ran by the following command 
after replacing the `[pod-name]`:

[role='command']
```
kubectl exec -it [pod-name] /opt/ol/wlp/bin/server pause defaultServer
```

Repeat the GET request. You'll see the same `session-id` 
but a different `pod-name` because the session data is cached but the request
is served by a different pod (server).

Verify that the Hazelcast cluster is running by checking the Open Liberty log. 
Run the following command:

[role='command']
```
kubectl exec -it [pod-name] cat /logs/messages.log
```

You'll see a message similar to the following:

[role="no_copy"]
----
... I [10.1.0.46]:5701 [CartCluster] [3.11.2] 

Members {size:3, ver:3} [
	Member [10.1.0.40]:5701 - 01227d80-501e-4789-ae9d-6fb348d794ea
	Member [10.1.0.41]:5701 - a68d0ed1-f50e-4a4c-82b0-389f356b8c73 this
	Member [10.1.0.42]:5701 - b0dfa05a-c110-45ed-9424-adb1b2896a3d
]
----

You may resume the paused pod by running the following command:

[role='command']
```
kubectl exec -it [pod-name] /opt/ol/wlp/bin/server resume defaultServer
```


// =================================================================================================
// Tear Down
// =================================================================================================

== Tearing down the environment

When you no longer need your deployed application, you can delete all {kube} resources 
by running the `kubectl delete` command:

[role='command']
```
kubectl delete -f kubernetes.yaml
```

[role='command']
include::{common-includes}/kube-minikube-teardown.adoc[]


== Great work! You're done!

You created, used and cached HTTP session data for an application running on Open Liberty server
deployed in a Kubernetes cluster.


include::{common-includes}/attribution.adoc[subs="attributes"]
